#version 430

layout(binding = 0, rgba8) uniform image2D outputTexture;
layout(binding = 1, rgba8) coherent uniform image3D voxel;

layout(std430, binding = 1) buffer Camera {
	mat4 P;
	mat4 V;
	mat4 I;
};

layout(std430) struct Node {
	int child[8];
};

layout(std430, binding = 2) buffer Octree {
	Node n[1000];
};

struct Ray{
	vec3 origin;
	vec3 dir;
};

bool findVoxel(vec3 p) {
	return true;
}

/*
 * check ray entering a solid space
 */
bool check(vec3 p) {
	//vec3 mp = mod(p, 3.0);
	//return floor(mp) == vec3(0) || ceil(mp) - 1 == vec3(0);

	vec4 pa = imageLoad(voxel, ivec3( 64 + floor(p) ));
	vec4 pb = imageLoad(voxel, ivec3( 64 + ceil(p) - 1 ));

	//if (pa.a > 0) {
	//	return pa;
	//}
	//else if (pb.a > 0) {
	//	return pb;
	//}
	//return vec4(0);

	return pa.a > 0 || pb.a > 0;
}

vec3 intersectOct(Ray r){

		float voxel_size = 128.0;
		vec3 next = r.origin;

		// position inside voxel
		vec3 modu = mod(next, voxel_size);
		if ( r.dir.x <= 0 && modu.x <= 0 ) modu.x = voxel_size;
		if ( r.dir.y <= 0 && modu.y <= 0 ) modu.y = voxel_size;
		if ( r.dir.z <= 0 && modu.z <= 0 ) modu.z = voxel_size;

		// multiple of each element required to reach next voxel
		// modu + t * r.dir = ceil( r.dir ) = 1 or 0
		vec3 t = ( voxel_size * ceil( r.dir ) - modu ) / r.dir;

		float min = t.x;
		if (t.y < min) min = t.y;
		if (t.z < min) min = t.z;

		next += min * r.dir;

		if ( min == t.x ) {
			next.x = round(next.x);
			edge = vec3(sign( -r.dir.x ), 0, 0);
		}
		if ( min == t.y ) {
			next.y = round(next.y);
			edge = vec3(0, sign( -r.dir.y ), 0);
		}
		if ( min == t.z ) {
			next.z = round(next.z);
			edge = vec3(0, 0, sign( -r.dir.z ));
		}


}

vec3 intersect(Ray r){
	float k = 0.0;
	vec3 edge = vec3(0);
	vec3 next = r.origin;
	vec3 outcol = vec3(0);
	float q = 1.0;
	while (k < 1.0) {
		//vec4 col = check( next );
		if ( check( next ) ) {
			float diff = q - q * 0.4;
			q *= 0.4;
			outcol += diff * vec3(0.1, 0.1, 0.1);
			r.dir = reflect(r.dir, -edge); // col.xyz
		}

		// position inside voxel
		vec3 modu = mod(next, 1.0);
		if ( r.dir.x <= 0 && modu.x <= 0 ) modu.x = 1.0;
		if ( r.dir.y <= 0 && modu.y <= 0 ) modu.y = 1.0;
		if ( r.dir.z <= 0 && modu.z <= 0 ) modu.z = 1.0;

		// multiple of each element required to reach next voxel
		// modu + t * r.dir = ceil( r.dir ) = 1 or 0
		vec3 t = ( ceil( r.dir ) - modu ) / r.dir;

		float min = t.x;
		if (t.y < min) min = t.y;
		if (t.z < min) min = t.z;

		next += min * r.dir;

		if ( min == t.x ) {
			next.x = round(next.x);
			edge = vec3(sign( -r.dir.x ), 0, 0);
		}
		if ( min == t.y ) {
			next.y = round(next.y);
			edge = vec3(0, sign( -r.dir.y ), 0);
		}
		if ( min == t.z ) {
			next.z = round(next.z);
			edge = vec3(0, 0, sign( -r.dir.z ));
		}
		k += 0.015;
	}
	outcol += q * r.dir;

	return outcol;
}


Ray initRay(uint x_in, uint y_in){
	Ray r;

	float x = ( float(x_in) / 1536.0 )*2.0 - 1.0;
	float y = ( float(y_in) / 864.0 )*2.0 - 1.0;

	vec4 pt1 = vec4(x, y, 0.0, 1.0);
	vec4 pt2 = vec4(x, y, 1.0, 1.0);

	vec4 pos1 = I * pt1;
	vec4 pos2 = I * pt2;

	r.origin = pos1.xyz;
	r.dir = normalize((pos2).xyz);

	return r;
}

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(){
	uint x = gl_GlobalInvocationID.x;
	uint y = gl_GlobalInvocationID.y;

	Ray r = initRay(x, y);

	vec3 outdir = intersect(r);
	vec4 color = vec4(outdir/2.0 + 0.5, 1.0);

	imageStore(outputTexture, ivec2(x, y), color);
}